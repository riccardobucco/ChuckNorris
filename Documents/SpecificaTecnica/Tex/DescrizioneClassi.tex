\level{1}{Descrizione delle classi}
	\level{2}{Legenda}
		Viene riportata in seguito la legenda riguardante i diagrammi presenti in tale sezione. Sono stati utilizzati colori diversi per classi con compiti diversi:
		\begin{itemize}
			\item le classi in grigio rappresentano librerie o moduli esterni, sui quali non abbiamo alcuna responsabilità;
			\item le classi in arancione sono tutte le classi factory presenti e le interfacce che esse implementano;
			\item le classi in verde sono le classi del modello che implementano l'interfaccia Updater e l'interfaccia Updater stessa;
			\item le classi in rosa sono le classi del modello che implementano la classe ChartImpl.
		\end{itemize}
	\level{2}{Norris}
		In questa sezione sono presenti le descrizioni di tutte le classi presenti all'interno del prodotto Norris. Queste sono state suddivise in base al componente nelle quali sono contenute.
		
		\level{3}{Design pattern utilizzati}
			Nella progettazione delle classi di Norris abbiamo deciso di utilizzare alcuni design pattern. Riportiamo di seguito una loro breve descrizione e il contesto nel quale sono stati utilizzati.
			\level{4}{Observer}
				L'Observer è un pattern comportamentale che ha lo scopo di monitorare lo stato di diversi oggetti legati ad un soggetto.
				Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:observer}.
				\level{5}{Contesto di utilizzo}
					Il pattern Observer si basa sugli oggetti “osservabili” e sugli “osservatori”.\\
					Le interfacce che che estendono Observable sono le seguenti:
					\begin{itemize}
						\item DataModel::ChartModel;
						\item DataModel::NorrisModel.
					\end{itemize}
					L'interfaccia Observer è implementata dalla classe EventEmitter fornita da Node.js.
			\level{4}{Bridge}
				Il Bridge è un pattern strutturale pensato per separare l'interfaccia di una classe dalla sua implementazione.\\
				Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:bridge}.
				\level{5}{Contesto di utilizzo}
					In Norris questo pattern viene utilizzato nel package InternalAPIManager per separare l'implementazione dei chart (presente nel package DataModel) dall'interfaccia fornita allo sviluppatore.
			\level{4}{Dependency Injection}
				Dependency Injection è un pattern architetturale il cui scopo è separare il comportamento di una componente dalla risoluzione delle sue dipendenze.\\
				Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:dependencyinjection}.
				\level{5}{Contesto di utilizzo}
					Il pattern Dependency Injection viene utilizzato con le classi che implementano le seguenti interfacce:
					\begin{itemize}
						\item ExternalAPIManager::EndpointFactory, inietta in ExternalAPIManager::ExternalAPIController le dipendenze verso i diversi Endpoint;
						\item DataModel::ChartFactory, inietta in DataModel::ChartImpl le  corrispondenze tra i tipi di grafico e le rispettive classi factory;
						\item DataModel::Updater, inietta in DataModel::ChartImpl le corrispondenze tra i diversi tipi di aggiornamenti e le classi che li implementano.
					\end{itemize}
			\level{4}{Singleton}
				Il Singleton è un pattern creazionale il cui scopo è permettere la creazione di una sola istanza di una classe, nonchè di fornire un punto di accesso globale ad essa.\\
				Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:singleton}.
				\level{5}{Contesto di utilizzo}
					Le classi che implementano il Singleton sono quelle che si occupano di creare i diversi tipi di grafici. Le riportiamo di seguito:
					\begin{itemize}
						\item DataModel::BarChartFactory;
						\item DataModel::LineChartFactory;
						\item DataModel::MapChartFactory;
						\item DataModel::TableFactory;
						\item ExternalAPIManager::ChartEndpoitFactory;
						\item ExternalAPIManager::AuthenticationEndpointFactory;
						\item ExternalAPIManager::ListEndpointFactory.
					\end{itemize}
			\level{4}{Abstract Factory}
				Il pattern creazionale Abstract Factory si occupa di fornire un'interfaccia per la creazione di famiglie di prodotti, senza dover specificare classi concrete.\\
				Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:abstractfactory}.
				\level{5}{Contesto di utilizzo}
					Gli elementi che implementano Abstract Factory sono quelli indicati in seguito.
					\begin{itemize}
					\item Interfacce:
						\begin{itemize}
							\item ChartFactory, con cui vengono generati i diversi tipi di grafici;
							\item ExternalAPIManager::EndpointFactory, con cui sono generati i diversi tipi di controller dei grafici.
						\end{itemize}
					\item Classi:
						\begin{itemize}
							\item DataModel::BarChartFactory;
							\item DataModel::LineChartFactory;
							\item DataModel::MapChartFactory;
							\item DataModel::TableFactory;
							\item ExternalAPIManager::ChartEndpointFactory;
							\item ExternalAPIManager::AuthenticationEndpointFactory;
							\item ExternalAPIManager::ListEndpointFactory.
						\end{itemize}
					\end{itemize}
					
		\input{Classi/Norris.tex}
		\input{Tex/ClassiAggiuntiveNorris.tex}
		\input{Tex/InterazioniClassiNorris.tex}
		
	\level{2}{Chuck}
		In questa sezione sono presenti le descrizioni di tutte le classi presenti all'interno del prodotto Chuck. Queste sono state suddivise in base al componente nelle quali sono contenute.
		
		\level{3}{Design pattern utilizzati}
Nella progettazione delle classi di Chuck abbiamo deciso di utilizzare alcuni design pattern. Riportiamo di seguito una loro breve descrizione e il contesto nel quale sono stati utilizzati.
\level{4}{Observer}
	L'Observer è un pattern comportamentale che ha lo scopo di monitorare lo stato di diversi oggetti legati ad un soggetto.
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:observer}.
	\level{5}{Contesto di utilizzo}
	Il pattern Observer si basa sugli oggetti “osservabili” e sugli “osservatori”. \\In Chuck il nucleo dell'implementazione dell'Observer si trova nel package Utils, in cui sono contenute le interfacce Observer e Observable, e la classe ObservableImpl che è l'implementazione di Observable. Questi tre elementi vengono poi estesi o implementati dagli altri elementi della libreria per realizzare il pattern completo.\\
	Interfacce che estendono Observable:
	\begin{itemize}
	\item ChartView::View;
	\item DataModel::ChartModel.
	\end{itemize}
	Interfacce che estendono Observer:
	\begin{itemize}
	\item ChartView::View.
	\end{itemize}
	Classi che estendono ObservableImpl:
	\begin{itemize}
	\item ChartView::ViewImpl;
	\item DataModel::ChartImpl.
	\end{itemize}
\level{4}{Bridge}
	Il Bridge è un pattern strutturale pensato per separare l'interfaccia di una classe dalla sua implementazione.\\ Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:bridge}.
	\level{5}{Contesto di utilizzo}
	In Chuck questo pattern viene utilizzato nel package ChuckAPIManager per separare l'implementazione dei chart (presente nel package DataModel) dall'interfaccia fornita allo sviluppatore client.
\level{4}{Dependency Injection}
	Dependency Injection è un pattern architetturale il cui scopo è separare il comportamento di una componente dalla risoluzione delle sue dipendenze.\\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:dependencyinjection}.
	\level{5}{Contesto di utilizzo}
	La Dependency Injection viene utilizzata con le classi che implementano le interfaccie DataModel::ChartFactory e DataModel::Updater. Attraverso queste classi vengono "iniettate" nella classe DataModel::ChartImpl rispettivamente le corrispondenze tra i tipi di grafico e le rispettive classi factory e le corrispondenze tra i diversi tipi di aggiornamenti e le classi che li implementano.
\level{4}{Singleton}
	Il Singleton è un pattern creazionale il cui scopo è permettere la creazione di una sola istanza di una classe e fornire un punto di accesso globale ad essa.\\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:singleton}.
	\level{5}{Contesto di utilizzo}
	Le classi che implementano il Singleton sono quelle che si occupano di creare i diversi tipi di grafici. cioè:
	\begin{itemize}
	\item DataModel::BarChartFactory;
	\item DataModel::LineChartFactory;
	\item DataModel::MapChartFactory;
	\item DataModel::TableFactory.
	\end{itemize}
\level{4}{Abstract Factory}
	Il pattern creazionale Abstract Factory si occupa di fornire un'interfaccia per la creazione di famiglie di prodotti, senza dover specificare classi concrete. \\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:abstractfactory}.
	\level{5}{Contesto di utilizzo}
	Gli elementi che implementano Abstract Factory sono:
	\begin{itemize}
	\item Interfacce:
		\begin{itemize}
			\item DataModel::ChartFactory, con cui vengono generati i diversi tipi di grafici.
		\end{itemize}
	\item Classi:
		\begin{itemize}
			\item DataModel::BarChartFactory;
			\item DataModel::LineChartFactory;
			\item DataModel::MapChartFactory;
			\item DataModel::TableFactory.
		\end{itemize}
	\end{itemize}
\level{4}{Adapter}
	Il pattern strutturale Adapter viene utilizzato per adattare l'interfaccia di una classe in un'altra.\\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:adapter}.
	\level{5}{Contesto di utilizzo}
	In Chuck l'Adapter viene utilizzato per calare le varie librerie esterne nel contesto di \projectname{}, e nello specifico sono rappresentate dalle diverse View, quindi:
	\begin{itemize}
	\item View::BarChartView e View::LineChartView sono adattatori per Chart.js;
	\item View::MapChartView è un adattatore per OpenStreetMaps;
	\item View::TableView è un adattatore per Dynatable.
	\end{itemize}
	
		\input{Classi/Chuck.tex}
		\input{Tex/ClassiAggiuntiveChuck.tex}
		\input{Tex/InterazioniClassiChuck.tex}
	
	\level{2}{Applicazione Android}
		In questa sezione sono presenti le descrizioni di tutte le classi presenti all'interno dell'applicazione Android. Queste sono state suddivise in base al componente nelle quali sono contenute.
		\level{3}{Design pattern utilizzati}
Nella progettazione delle classi dell'applicazione abbiamo deciso di utilizzare alcuni design pattern. Riportiamo di seguito una loro breve descrizione e il contesto nel quale sono stati utilizzati.
\level{4}{Observer}
	L'Observer è un pattern comportamentale che ha lo scopo di monitorare lo stato di diversi oggetti legati ad un soggetto.
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:observer}.
	\level{5}{Contesto di utilizzo}
	Il pattern Observer si basa sugli oggetti “osservabili” e sugli “osservatori”. \\ Nell'applicazione Android il nucleo dell'implementazione dell'Observer si trova nel package Utils, in cui sono contenute le interfacce Utils::Observer e Utils::Observable, e la classe Utils::ObservableImpl (implementazione di Utils::Observable). Questi tre elementi vengono poi estesi o implementati dagli altri elementi della libreria per realizzare il pattern completo.\\
	Interfacce che estendono Observable:
	\begin{itemize}
	\item Model::Chart.
	\end{itemize}
	Classi che implementano Observer:
	\begin{itemize}
	\item Controller::Controller;
	\item View::ChartActivity.
	\end{itemize}
	Classi che estendono ObservableImpl:
	\begin{itemize}
	\item View::ObservableImpl;
	\item Model::ChartImpl.
	\end{itemize}
\level{4}{Dependency Injection}
	Dependency Injection è un pattern architetturale il cui scopo è separare il comportamento di una componente dalla risoluzione delle sue dipendenze.\\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:dependencyinjection}.
	\level{5}{Contesto di utilizzo}
	La Dependency Injection viene utilizzata con le classi che implementano le seguenti interfacce:
	\begin{itemize}
	\item Controller::ControllerFactory, inietta in Controller::ChartController le corrispondenze tra i tipi di controller e le rispettive classi factory;
	\item Model::ChartFactory, inietta in Model::ChartImpl le  corrispondenze tra i tipi di grafico e le rispettive classi factory;
	\item Model::Updater, inietta in Model::ChartImpl le corrispondenze tra i diversi tipi di aggiornamenti e le classi che li implementano.
	\end{itemize}
\level{4}{Singleton}
	Il Singleton è un pattern creazionale il cui scopo è permettere la creazione di una sola istanza di una classe, nonchè di fornire un punto di accesso globale ad essa.\\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:singleton}.
	\level{5}{Contesto di utilizzo}
	Nell'applicazione Android il Singleton viene implementato nella classe Controller::JSONParser.
\level{4}{Abstract Factory}
	Il pattern creazionale Abstract Factory si occupa di fornire un'interfaccia per la creazione di famiglie di prodotti, senza dover specificare classi concrete. \\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:abstractfactory}.
	\level{5}{Contesto di utilizzo}
	Gli elementi che implementano Abstract Factory sono:
	\begin{itemize}
	\item Interfacce:
		\begin{itemize}
			\item Model::ChartFactory, con cui vengono generati i diversi tipi di grafici;
			\item Controller::ControllerFactory, con cui sono generati i diversi tipi di controller dei grafici.
		\end{itemize}
	\item Classi:
		\begin{itemize}
			\item Model::BarChartFactory;
			\item Model::LineChartFactory;
			\item Model::MapChartFactory;
			\item Model::TableFactory;
			\item Controller::BarChartControllerFactory;
			\item Controller::LineChartControllerFactory;
			\item Controller::MapChartControllerFactory;
			\item Controller::TableControllerFactory.
		\end{itemize}
	\end{itemize}
\level{4}{Adapter}
	Il pattern strutturale Adapter viene utilizzato per adattare l'interfaccia di una classe in un'altra.\\
	Per la descrizione del pattern e dei vantaggi derivanti dalla sua applicazione si rimanda all'appendice \nameref{app:adapter}.
	\level{5}{Contesto di utilizzo}
	Nell'applicazione Android l'Adapter viene utilizzato per calare le varie librerie esterne nel contesto di \projectname{}, e nello specifico sono rappresentate dalle diverse View, quindi:
	\begin{itemize}
	\item View::BarChartActivity è un adattatore per MPABarChart;
	\item View::MapChartActivity è un adattatore per GoogleMap Android API v2;
	\item View::LineChartActivity è un adattatore per MPALineChart.
	\end{itemize}
	
		\input{Classi/Applicazione.tex}
		\input{Tex/ClassiAggiuntiveApp.tex}
		\input{Tex/InterazioniClassiApplicazione.tex}

\level{1}{Design Patterns} \label{app:designpattern}
	\level{2}{Model View Controller} \label{app:MVC}
		Il Model-View-Controller (MVC) è un pattern architetturale utilizzato per dividere il codice in blocchi di funzionalità ben distinte, e viene utilizzato molto frequentemente nelle applicazioni in cui un insieme di informazioni deve essere rappresentato attraverso una interfaccia grafica.
		\level{3}{Componenti}
			MVC è quindi basato sul principio del disaccoppiamento dei tre oggetti di cui è composto, ovvero sulla riduzione del loro grado di dipendenza reciproca, allo scopo di fornire una maggiore robustezza, modularità e manutenibilità al software.\\
			Di seguito si riporta una breve descrizione dei componenti e delle loro caratteristiche. 
			\level{4}{Model}
				Il Model è il nucleo dell'applicazione. Definisce il modello dei dati realizzando la business logic, ovvero definisce gli oggetti secondo la logica di utilizzo dell'applicazione indicande anche le possibili operazioni effettuabili su di essi.\\
				Questo componente viene generalmente progettato attaverso tecniche object oriented.\\
				Nella struttura del pattern MVC, il Model è un componente passivo, che non ha relazioni uscenti forti, ma si occupa di notificare alla View eventuali aggiornamenti avvenuti in esso, solitamente attraverso l'implementazione del pattern Observer.
			\level{4}{View}
				La View si occupa di visualizzare i dati contenuti nel Model e fornisce l'interfaccia di interazione con utenti e agenti.\\
				Nella struttura del pattern MVC, la View cattura gli input dell'utente e li passa al Controller affinchè esegua le corrette operazioni sul Model. \\
				La View può essere soggetta a due tipi di aggiornamento:
				\begin{itemize}
					\item \textbf{Push model:} viene implementato attraverso il pattern Observer e soltanto quando MVC è usato in un solo ambiente di esecuzione; consiste nel fatto che sia il Model a emettere, senza essere sollecitato, la notifica in seguito alla quale la View verrà aggiornata.
					\item \textbf{Pull model:} viene implementato quando MVC è usato su diversi ambienti di esecuzione; in questo caso la View richiede al Model se sia necessario un aggiornamento solo al verificarsi di particolari eventi.
				\end{itemize}
			\level{4}{Controller}
				Il Controller è il collante fra la View e il Model. Si occupa infatti di implementare l'application logic, cioè l'insieme di operazioni eseguibili sul modello dei dati attraverso una particolare vista.\\
				Poichè potenzialmente possono esistere più View (si pensi per esempio ad una applicazione che dispone sia di una interfaccia web che di una applicazione per smartphone) è necessario che ad ogni View corrisponda un Controller.
 		\level{3}{Vantaggi nell'uso di MVC}
			Come detto, l'utilizzo del pattern MVC porta la riduzione delle dipendenze, offrendo diversi vantaggi. La modularità ottenuta permette il riutilizzo del Model in applicazioni con diverse View, oltre a rendere più semplice e rapida l'esecuzione di test. 
 		\level{3}{Svantaggi nell'uso di MVC}
			L'utilizzo del pattern MVC nello sviluppo di un software non ha solo benefici, ma ha anche un piccolo costo, derivante da una maggiore complessità e dalla necessità di un maggior numero di aggiornamenti.\\
  			La maggiore complessità è data dai livelli di indirezione introdotti dal pattern e dall'implementazione ad eventi necessaria per far comunicare i tre componenti. La maggiore frequenza degli aggiornamenti, invece, è un effetto collaterale della modularizzazione: frequenti cambiamenti al modello comportano spesso cambiamenti nelle View e quindi nei Controller.
	\level{2}{Singleton} \label{app:singleton}
		Lo scopo del pattern architetturale denominato Singleton è 
		assicurare l'esistenza di un'unica istanza di una classe e fornire
		un punto di accesso globale ad essa.\\
		Questo pattern è nato per rispondere alla necessità di non avere più
		istanze della stessa classe, anche nei linguaggi in cui non è possibile 
		usare una variabile globale, pur dando la possibilità alla classe di
		tener traccia di quella sua istanza.\\
		Il pattern Singleton è quindi applicabile ogniqualvolta debba esistere una 
		sola istanza di una certa classe in tutta l'applicazione, prestando però attenzione 
		al fatto che l'istanza sia estendibile tramite ereditarietà.\\
		Viene generalmente utilizzato per implementare altri pattern come Factory, 
		Builder e Façade.
		\level{3}{Vantaggi nell'uso del Singleton}
		L'utilizzo del Singleton nell'implementazione di un software apporta i seguenti 
		vantaggi:
		\begin{itemize}
		\item controllo completo di come e quando i client acedono all'interfaccia;
		\item evita l'utilizzo ingiustificato di variabili globali;
		\item consente di ridefinire le operazioni definite nel Singleton;
		\item permette di porre un limite massimo al numero di istanze di una certa classe.
		\end{itemize}
	\level{2}{Dependency injection} \label{app:dependencyinjection}
Il Dependency Injection è un pattern architetturale utilizzato nella programmazione Object-Oriented il cui scopo è separare il comportamento di una componente dalla risoluzione delle sue dipendenze. \\
Questo particolare pattern si basa su tre elementi:
\begin{itemize}
\item una componente dipendente;
\item la dichiarazione delle dipendenze della componente, dette interface contracts;
\item un injector, detto anche provider, che crea su richiesta le istanze delle classi che implementano le dipendenze.
\end{itemize}
Il principio di programmazione adottato è quello dell'inversione di controllo, secondo il quale il ciclo di vita degli oggetti viene gestito da un'entità esterna (container).\\
Nel Dependency Injection implementato con l'inversione di controllo le dipendenze vengono inserite dal container, la componente si limita a dichiararle. In questo modo viene raggiunto l'obiettivo di ridurre le dipendenze fra classi.\\
Esistono due tipi di Dependency Injection:
\begin{description}
	\item[Constructor injection:] le dipendenze vengono dichiarate come parametri del costruttore; in questo modo un oggetto è valido appena viene istanziato.
	\item[Setter injection:] le dipendenze vengono dichiarate come metodi setter; in questo modo vengono evidenziate le dipendenze.
\end{description}

\level{3}{Vantaggi nell'uso di dependency injection}
L'utilizzo del pattern Dependency Injection nella progettazione dell'architettura di un software porta i seguenti vantaggi:
\begin{itemize}
\item la componente individuata come client è più facile da testare singolarmente attraverso l'uso di stub;
\item permette di esternalizzare i dettagli della configurazione del sistema in un file di configurazione, consentendo così di riconfigurare il sistema senza ricompilarlo;
\item permette lo sviluppo concorrente e indipendente del software;
\item diminuisce l'accoppiamento tra una classe e la sua dipendenza.
\end{itemize}
\level{3}{Svantaggi nell'uso di dependency injection}
Dependency Injection ha anche delle possibili ripercussioni negative sul software che lo utilizza. Esso infatti può rendere il codice difficile da leggere in quanto permette la separazione fra dichiarazione e comportamento, oltre a richiedere più righe di codice rispetto alla scrittura di codice "tradizionale" per ottenere lo stesso comportamento.

	\level{2}{Observer} \label{app:observer}
		Observer è un pattern comportamentale, implementato in numerose librerie di programmazione e sistemi, il cui scopo è quello di tenere sotto controllo lo stato di diversi oggetti legati ad un soggetto (dipendenza uno a molti). \\
		Il paradigma corrisponde al modello Publisher and Subscribe: i sottoscrittori si registrano presso un pubblicatore e quest’ultimo li informa ogni volta che ci sono nuove notizie (del genere sottoscritto).\\
		Il pattern è composto da:
		\begin{itemize}
		\item una classe astratta “Subject”, da cui eredita il soggetto concreto, che mantiene una lista di riferimenti agli oggetti dipendenti per poterli avvisare;
		\item Un’interfaccia “Observer” implementata dagli osservatori concreti, che tengono il riferimento al soggetto per poterne leggere lo stato.
		\end{itemize}
		\level{3}{Vantaggi nell’uso di observer}
			L’utilizzo del pattern Observer nella progettazione dell’architettura porta i seguenti vantaggi:
			\begin{itemize}
			\item minimizzazione dell’accoppiamento tra Observer e Subject, che possono essere usati indipendentemente gli uni dagli altri;
			\item aumento del grado di riuso dei singoli tipi;
			\item non si debbono fare assunzioni sugli oggetti dipendenti se si ha necessità di comunicare con loro;
			\item libertà di aggiungere osservatori dinamicamente alla lista, senza modificare il Subject.
			\end{itemize}

			\level{3}{Svantaggi nell'uso di Observer}
			L’utilizzo di Observer potrebbe causare:
			\begin{itemize}
			\item possibile cascata di notifiche: poiché gli observer mutuamente si ignorano, una richiesta di modifica può avere effetti incontrollati, scatenando la reazione degli altri;
			\item “memory leak” in quanto nelle implementazioni di base il subject richiede sia l’esplicita registrazione che l’esplicita rimozione dalla lista delle dipendenze legandosi in modo forte agli observer, tenendoli attivi. Questo problema può essere prevenuto riferendo in modo debole gli observer.
			\end{itemize}
